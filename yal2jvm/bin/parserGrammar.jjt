options
{
  LOOKAHEAD=1;
}

PARSER_BEGIN(parserGrammar)

import java.io.*;

public class parserGrammar
{
  public static void main(String args []) throws ParseException, FileNotFoundException
  {
	parserGrammar parser = new parserGrammar(System.in);
	parser.Module();
    /*parserGrammar parser;
    
    InputStream stream = new FileInputStream(args[0]);
    parser = new parserGrammar(stream);
      
	parser.Module();*/
  }
}

PARSER_END(parserGrammar)

JAVACODE
void skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
}


JAVACODE
void skipto_do_not_consume_last(int kind) {
  ParseException e = generateParseException();  // generate the exception object.
  System.out.println(e.toString());  // print the error message
  Token t;
  int token_kind;
  boolean consume = false;
  do{

	if(consume)
		t = getNextToken();

	token_kind = jj_ntk();
	
	consume = true;
   	
  } while (token_kind != kind);

}


<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
<DEFAULT> TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

<DEFAULT> TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

void Module():{}
{
  	
  	<MODULE> <ID> <LCHAVETA>  ( Declaration() )*

	try { 

  		( Function() )* <RCHAVETA>

 	}

 	catch(ParseException exception) {

		skipto(RCHAVETA);

 	}

}

void Declaration():{}
{
	try { 

		( LOOKAHEAD(<ID>"[" "]") ArrayElement() | ScalarElement() ) ( <ASSIGN> ( ( "[" ArraySize() "]" ) | (<ADDSUB_OP> )? <INTEGER> ) )? <PVIRG>
	}

	catch(ParseException exception) {
		System.out.println("CATCH DECLARATION");
		skipto(PVIRG);
	}
}


void Function():{}
{
  	try {
		    
  		( LOOKAHEAD(3) ( <FUNCTION> ( LOOKAHEAD(2) ArrayElement() | ScalarElement() ) <ASSIGN> <ID> ) |
  		( <FUNCTION> <ID>  ))
		<LPAR> 
	}

	catch(ParseException exception) {
		System.out.println("CATCH FUNCTION");
		 //System.out.println(exception.currentToken.image);
		 //System.out.println(exception.getMessage());
	  	skipto(LPAR);
	}

	try {
	  ( Varlist() )? <RPAR>

	}

	catch(ParseException exception) {
		System.out.println("CATCH VARLIST RPAR");
		skipto(RPAR);
	}

	<LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist():{}
{
  	try {
  	  
		( LOOKAHEAD(2) ArrayElement() | ScalarElement() ) ( <VIRG> ( LOOKAHEAD(2) ArrayElement() | ScalarElement() ))*

	}

	catch(ParseException exception) {
		System.out.println("CATCH VARLIST");
		skipto_do_not_consume_last(RPAR);
	}
}

void ArrayElement():{}
{
<ID> "[" "]"
}

void ScalarElement():{}
{
  	//try { 
		<ID>
	/*}
	catch(ParseException exception) {

		System.out.println("CATCH SCALARELEMENT");
	}*/
}

void Stmtlst():{}
{
	try { 
		( Stmt() )*
	}

	catch(ParseException exception) {
  		System.out.println("CATCH STMLST");
	}
}

void Stmt():{}
{
	try {
  		While()
		| If()
		| LOOKAHEAD(3) Assign()
		| Call() <PVIRG>
	}

	catch(ParseException exception) {
		System.out.println("CATCH STMT");
		skipto(PVIRG);
	}

}

void Assign():{}
{
		Lhs() <ASSIGN> Rhs() <PVIRG>
}

void Lhs():{}
{
 		LOOKAHEAD(2) ArrayAccess()
		| ScalarAccess()
}

void Rhs():{}
{
		( Term() ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term() )? )
		| "[" ArraySize() "]"
}

void ArraySize():{}
{
		ScalarAccess()
		| <INTEGER>
}

void Term():{}
{
		( <ADDSUB_OP> )? ( <INTEGER> | LOOKAHEAD(3) Call() | LOOKAHEAD(2) ArrayAccess() | ScalarAccess()
		)
}

void Exprtest ():{}
{
  try { 
 		<LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
	}

	catch (ParseException exception) {
		System.out.println("CATCH EXPRTEST");
  		skipto(RPAR);
	}
}

void While():{}
{
  
	try { 

		<WHILE> Exprtest() <LCHAVETA>
	}

	catch(ParseException exception) {

		System.out.println("CATCH WHILE");
		skipto(LCHAVETA);

	}

	Stmtlst() <RCHAVETA>
}

void If():{}
{
 		<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> ( <ELSE> <LCHAVETA>
		Stmtlst() <RCHAVETA> )?
}

void Call():{}
{
  	
		<ID> ( "." <ID> )? <LPAR> ( ArgumentList() )? <RPAR>
	
}

void ArgumentList():{}
{
 	Argument() ( <VIRG> Argument() )*
}

void Argument():{}
{
  	( <ID> | <STRING> | <INTEGER> )
}

void ArrayAccess():{}
{
	<ID> "[" Index() "]"
}

void ScalarAccess():{}
{
	<ID> ( "." <SIZE> )?
}

void Index():{}
{
		<ID>
		| <INTEGER>
}
