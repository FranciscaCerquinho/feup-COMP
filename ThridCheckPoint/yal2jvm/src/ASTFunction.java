/* Generated By:JJTree: Do not edit this line. ASTFunction.java Version 6.0 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.ArrayList;

public
class ASTFunction extends SimpleNode {
  private String name;

public ASTFunction(int id) {
  super(id);
}

public ASTFunction(parserGrammar p, int id) {
  super(p, id);
}

public String getName() {
  return name;
}

public void setName(String name) {
  this.name = name;
}

public String toString() {
  String test;

  test = super.toString() + " " + name;

  return test;
}

@Override
public boolean analyse(SymbolsTable currentTable){
  boolean isScalar = jjtGetChild(0).isScalar();
  if(currentTable.returnSymbol(name)!=null){
    System.out.println("Function already exists!");
    return true;
  }
  if(isScalar)
    currentTable.putOnHashMap(new Symbol("Function",name,true));
  else
    currentTable.putOnHashMap(new Symbol("Function",name,false));

  System.out.println("Function: " + " name: " + name + " Tipo: " + isScalar);

  return true;
}

@Override
public boolean analyseContent(SymbolsTable currentTable){
  System.out.println("Analyse children of Function");

  SymbolsTable symbolsTable = new SymbolsTable(currentTable);

  for(int i=0; i < jjtGetNumChildren();i++){
    jjtGetChild(i).analyse(symbolsTable);
  }

  return true;
}

public String convertToByteCodes(MapVariables data, int loop_no){
  String line = "";
  MapVariables mapVariables = new MapVariables(data);
  String returnType = "V";
  String returnArg = "";
  if(name.equals("main")){
    line += ".method public static main([Ljava/lang/String;)V" + "\n";
  }
  else{
    ArrayList<String> typeOfArgs = new ArrayList<String>();
    for(int i = 0; i < jjtGetNumChildren(); i++){
        if(jjtGetChild(i).getId() == parserGrammarTreeConstants.JJTVARLIST) {
          for(int j = 0; j < jjtGetChild(i).jjtGetNumChildren(); j++){
            if(jjtGetChild(i).jjtGetChild(j).getId() == parserGrammarTreeConstants.JJTARRAYELEMENT)
              typeOfArgs.add("[I");
            else if(jjtGetChild(i).jjtGetChild(j).getId() == parserGrammarTreeConstants.JJTSCALARELEMENT)
              typeOfArgs.add("I");
          }
        }
        else if(jjtGetChild(i).getId() == parserGrammarTreeConstants.JJTARRAYELEMENT) {
          returnType = "[I";
          returnArg = jjtGetChild(i).getName();
        }
        else if(jjtGetChild(i).getId() == parserGrammarTreeConstants.JJTSCALARELEMENT) {
          returnType = "I";
          returnArg = jjtGetChild(i).getName();
        }
    }

    String function = ".method public static " + name + "(";
    for(int k = 0; k < typeOfArgs.size(); k++){
      function += typeOfArgs.get(k);
    }
    function += ")" + returnType;

    line += function + "\n";

  }

  line +=".limit locals 10" + "\n";
  line +=".limit stack 10" + "\n";

  for(int i = 0; i < jjtGetNumChildren(); i++){
    line += jjtGetChild(i).convertToByteCodes(mapVariables, loop_no);
  }

  if(returnType.equals("V"))
    line += "return" + "\n";
  else {
    line += "iload_" + mapVariables.returnByteCode(returnArg) + "\n";
    line += "ireturn" + "\n";
  }
    line += ".end method" + "\n";
    line += "\n";

    return line;

}

public ArrayList<String> getFunction() {

  String returnType = "V";
  String name = this.name;
  for(int i = 0; i < jjtGetNumChildren(); i++){
      if(jjtGetChild(i).getId() == parserGrammarTreeConstants.JJTARRAYELEMENT) {
        returnType = "[I";
      }
      else if(jjtGetChild(i).getId() == parserGrammarTreeConstants.JJTSCALARELEMENT) {
        returnType = "I";
      }
  }
  ArrayList<String> returns = new ArrayList<String>();

  returns.add(name);
  returns.add(returnType);

  return returns;
}


}
/* JavaCC - OriginalChecksum=abac2313f4a585dbc8038a0f08c4989e (do not edit this line) */
